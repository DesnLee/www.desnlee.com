<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>JavaScript on DesnLee</title>
    <link>/tags/javascript/</link>
    <description>Recent content in JavaScript on DesnLee</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Wed, 14 Jul 2021 08:00:00 +0000</lastBuildDate><atom:link href="/tags/javascript/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>JavaScript 的跨域</title>
      <link>/post/crossorigin/</link>
      <pubDate>Wed, 14 Jul 2021 08:00:00 +0000</pubDate>
      
      <guid>/post/crossorigin/</guid>
      <description>什么是同源 如果两个 URL 的 protocol、port(如果有指定的话)和 host 都相同的话，则这两个 URL 是同源。
同源策略是一个重要的安全策略，它用于限制一个 origin 的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。
例如： 如果 JS 运行在 源A 里，那么就只能获取 源A 的数据，不能获取 源B 的数据，即不允许跨域。
什么是跨域 同源策略控制不同源之间的交互，例如在使用 XMLHttpRequest 或 &amp;lt;img&amp;gt; 标签时则会受到同源策略的约束。
这些交互通常分为三类：
 跨域写操作（Cross-origin writes）一般是被允许的。例如链接（links），重定向以及表单提交。特定少数的HTTP请求需要添加 preflight。 跨域资源嵌入（Cross-origin embedding）一般是被允许。 跨域读操作（Cross-origin reads）一般是不被允许的，但常可以通过内嵌资源来巧妙的进行读取访问。  跨域就是在不同源之间进行数据交互。
JSONP 跨域 由于同源策略，一般来说不同源之间无法进行沟通，而 HTML 的 &amp;lt;script&amp;gt; 元素是一个例外。利用 &amp;lt;script&amp;gt; 元素的这个开放策略，网页可以得到从其他来源动态产生的 JSON 资料，而这种使用模式就是所谓的 JSONP。
举一个具体例子，test1.com 想要访问 test2.com 的数据，
 首先 test2.com 先将数据写入一个文件 test2.com/data.js; test1.com 事先定义好一个函数 window.callback ; test1.com 通过 &amp;lt;script&amp;gt; 引用 test2.com/data.js ; 然后 data.</description>
    </item>
    
    <item>
      <title>原型链与继承</title>
      <link>/post/prototypechain/</link>
      <pubDate>Tue, 06 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>/post/prototypechain/</guid>
      <description>原型链 JavaScript 每个对象都有一个私有属性 __proto__ 指向它的构造函数的原型对象 prototype。该原型对象也有一个 __proto__，层层向上直到一个对象的原型对象__proto__为 null，作为这个原型链中的最后一个环节。
当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，会在该对象的原型链上依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。
基于原型链的继承 在 JavaScript 中，函数是允许拥有属性的。所有的函数会有一个特别的属性 prototype 。可以通过 Test.prototype 为原型添加属性。
然后我们可以通过 new 操作符来创建基于这个原型对象的 Test 实例。使用 new 操作符，只需在调用 Test 函数语句之前添加 new。这样，便可以获得这个函数的一个实例对象。一些属性就可以添加到该原型对象中。
function Test(){} //创建一个函数 Test.prototype.f1 = `f1` //为该函数原型添加自定义属性 let test1 = new Test() //基于 Test 函数创建函数实例 test1.f1 // &amp;#34;f1&amp;#34; 基于 class 的继承 ECMAScript6 引入了一套新的关键字用来实现 class，它仍然基于原型。
class Person { constructor(name, age) { this.name = name; this.age = age; } get hello() { console.log(`Hello, my name is ${this.</description>
    </item>
    
    <item>
      <title>Promise</title>
      <link>/post/promise/</link>
      <pubDate>Thu, 17 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>/post/promise/</guid>
      <description>Promise 的用途 在 JavaScript 的世界中，所有代码都是单线程执行的。由于这个特性，导致 JavaScript 的所有网络操作，浏览器事件，都必须是异步执行。
而 Promise 是异步编程的一种解决方案，比传统的解决方案（回调函数和事件）更合理更强大。它由社区最早提出和实现，ES6将其写进了语言标准，统一了语法，原生提供了 Promise。
所谓 Promise ，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。
本质上 Promise 是一个函数返回的对象，它代表了一个异步操作的最终完成或者失败。我们可以在它上面绑定回调函数，这样我们就不需要在一开始把回调函数作为参数传入这个函数了。
创建一个 new Promise return new Promise((resolve,reject)=&amp;gt;{}) 一个 Promise 必然处于以下几种状态之一：
 pending： 待定，初始状态，既没有被兑现，也没有被拒绝。 fulfilled： 已兑现，意味着操作成功完成。 rejected： 已拒绝，意味着操作失败。     resolve 函数的作用是，将 Promise 对象的状态从 &amp;ldquo;未完成&amp;rdquo; 变为 &amp;ldquo;成功&amp;rdquo; ，即从 pending 变为 resolved ，在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；
  reject 函数的作用是，将 Promise 对象的状态从 &amp;ldquo;未完成&amp;rdquo; 变为 &amp;ldquo;失败&amp;rdquo; ，即从 pending 变为 rejected ，在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。
   如何使用 Promise.prototype.then 待定状态的 Promise 对象要么会通过一个值被兑现（fulfilled），要么会通过一个 原因/错误 被拒绝（rejected）。当这些情况之一发生时，我们用 promise 的 then 方法排列起来的相关处理程序就会被调用。</description>
    </item>
    
    <item>
      <title>this、call、apply 和 bind</title>
      <link>/post/this/</link>
      <pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate>
      
      <guid>/post/this/</guid>
      <description>什么是 this ？ 在说 call、apply 和 bind 之前，我们先来看看 Javascript 中的 this 是什么。
先来看一段代码 ⬇️ ⬇️ ⬇️
var a = 1 const obj = { a: 2, fn: function() { console.log(this.a) } } const b = obj.fn obj.fn() // 2 b() // 1 上面代码中，虽然 obj.fn 和 b 指向同一个函数，但是执行结果不一样。这种差异的原因，就在于函数内使用了 this 关键字。 this 指的是函数运行时所在的环境。
在内存图中，变量 obj 的值指向了一个地址，这个地址里保存了 a 和 fn ，而由于 fn 是一个函数，那么 fn 的值也是一个地址，在 fn 指向这个地址中保存了 fn 这个函数的函数体，所以这个函数是一个单独的值，那么他就可以在不同的环境中执行。
 obj的内存图  this 就指的是函数运行时的环境。</description>
    </item>
    
    <item>
      <title>JavaScript 的闭包（Closure）</title>
      <link>/post/closure/</link>
      <pubDate>Sat, 15 May 2021 00:00:00 +0000</pubDate>
      
      <guid>/post/closure/</guid>
      <description>闭包是什么？ 闭包： 是指有权访问另一个函数作用域中的变量的函数。
闭包无处不在，比如 jQuery 、zepto 的核心代码都包含在一个大的闭包中。
先来看一个闭包 ⬇️ ⬇️ ⬇️
const outSide = () =&amp;gt; { let a = 1 const inSide = () =&amp;gt; { a ++ console.log(a) } return inSide } const fn = outSide() fn() // 2 fn() // 3 fn() // 4 闭包的用途 闭包的实现原理，其实是利用了作用域链的特性。
我们都知道作用域链就是在当前执行环境下访问某个变量时，如果不存在就向外层寻找，最终寻找到最外层也就是全局作用域，这样就形成了一个链条。
隐藏变量，避免污染 在 Javascript 中，如果一个对象不再被引用，那么这个对象就会被 GC 回收，否则这个对象一直会保存在内存中。
上面的代码，当函数 outSide 被执行后返回了函数 inSide ，函数inSide 的作用域链上有引用到函数 outSide 执行环境的变量 a，这个变量会被函数 fn 引用，所以 a 不会被垃圾回收机制处理掉，而是会留在内存中。这就形成了一个闭包。最后执行 fn() 依然能读取到变量 a。</description>
    </item>
    
    <item>
      <title>DOM 事件与事件委托</title>
      <link>/post/dom01/</link>
      <pubDate>Sat, 01 May 2021 02:00:00 +0000</pubDate>
      
      <guid>/post/dom01/</guid>
      <description>什么是 DOM 事件 文档对象模型 （Document Object Model） 是 HTML 和 XML 文档的编程接口。
它提供了对文档的结构化的表述，并定义了一种方式可以使从程序中对该结构进行访问，从而改变文档的结构，样式和内容。DOM 将文档解析为一个由节点和对象（包含属性和方法的对象）组成的结构集合。
文档对象模型（DOM）提供了对同一份文档的另一种表现，存储和操作的方式。 DOM 是 web 页面的完全的面向对象表述，它能够使用如 JavaScript 等脚本语言进行修改。
而事件是 JavaScript 与 HTML 交互的基础。要实现用户与页面的交互，先要通过 DOM 接口访问元素，再对目标元素绑定特定的事件、设置事件处理函数，然后用户触发事件，事件处理函数执行，产生交互效果。
DOM 事件模型和事件流 事件流又称为事件传播，描述的是从页面中接收事件的顺序。当一个事件发生后，会在子元素和父元素之间传播（propagation）。这种传播分成三个阶段。
 事件捕获阶段（capturing phase）： 事件从 window 对象自上而下向目标节点传播的阶段； 处于目标阶段（target phase）： 真正的目标节点正在处理事件的阶段； 事件冒泡阶段（bubbling phase）： 事件从目标节点自下而上向 window 对象传播的阶段。   在DOM2级事件流中，当我们点击下面的代码片段中的 div 元素后，在事件捕获阶段从上到下传播
 window &amp;ndash;&amp;gt; document -&amp;gt; html -&amp;gt; body &amp;ndash;&amp;gt; 目标
 &amp;lt;html&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div&amp;gt; 点我 &amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 而事件冒泡的流程刚好是事件捕获的逆过程，冒泡和捕获的过程如下图：  DOM 事件流模型</description>
    </item>
    
    <item>
      <title>jQuery 常用操作手册</title>
      <link>/post/jquery01/</link>
      <pubDate>Thu, 29 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>/post/jquery01/</guid>
      <description>jQuery 简介 jQuery 是一套跨浏览器的 JavaScript 库，简化 HTML 与 JavaScript 之间的操作。
据统计，全世界排名前 100 万的网站，有 76.85% 在使用 jQuery ，远远超过其他库（截止至2021年2月）。 点击查看统计数据 -&amp;gt;
在 jQuery 诞生前，人们是使用原生 JS 来对 DOM 等一系列做操作的，但 JS 提供的 DOM API 有点反人类。
因此，经过前端程序员们不断的努力和尝试，发明了现在这套经典的 JavaScript 函数库。
jQuery 常用操作 关于 jQuery 的全部 API，请查看 jQuery 中文文档，以下仅对常用的操作进行罗列。
选择网页元素 jQuery 的基本设计思想和主要用法，就是 选择某个网页元素，然后对其进行某种操作。这是它区别于其他 Javascript 库的根本特点。
使用 jQuery 的第一步，就是一个选择表达式，放进构造函数 jQuery()（简写为$），然后就可以对该元素进行操作了。
选择表达式可以是 CSS 选择器，也可以是 jQuery 特有的表达式
$(document) //选择整个文档  $(&amp;#39;#id&amp;#39;) //通过元素的 id 选择元素  $(&amp;#39;div.class&amp;#39;) // 通过 class 属性选择 div 元素  $(&amp;#39;input[name=name]&amp;#39;) // 通过 name 属性选择 input 元素  $(&amp;#39;a:first&amp;#39;) //选择网页中第一个 a 元素  $(&amp;#39;tr:odd&amp;#39;) //选择 tr 的奇数（odd）行  $(&amp;#39;#form :input&amp;#39;) // 选择表单中的 input 元素  $(&amp;#39;div:visible&amp;#39;) //选择可见（visible）的 div 元素  $(&amp;#39;div:gt(2)&amp;#39;) // 选择除了前三个余下的 div 元素，数字为下标  $(&amp;#39;div:animated&amp;#39;) // 选择当前处于动画状态的 div 元素 jQuery 设计思想之二，就是提供各种过滤器对结果集进行筛选进而缩小范围。</description>
    </item>
    
    <item>
      <title>JavaScript函数的执行时机</title>
      <link>/post/javascript06/</link>
      <pubDate>Mon, 05 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>/post/javascript06/</guid>
      <description>问题 有这么一段代码，打印的结果和预期不符
let i = 0 for(i = 0; i&amp;lt;6; i++){ setTimeout(()=&amp;gt;{ console.log(i) },0) } //6,6,6,6,6,6 预期的结果是打印出 0,1,2,3,4,5 ，但是执行的结果是 6,6,6,6,6,6
分析 上面这段代码，用到了 setTimeout ，setTimeout 的作用是设置一个定时器，定时器到期后执行一个函数或指定的一段代码。
上面的代码可以理解为：初始化 i 是 0，然后设置一个打印 i 的定时器，然后让 i 加 1，再次循环设置第二个定时器，直到 i 等于 6 则不再设置定时器，最后在退出 for 循环后，开始执行之前定的 6 个定时器。
由于定时器执行是在for循环结束之后，所以当for 循环结束后，i 的值是 6， 这时候执行 6个定时器，定时器的内容是打印 i，于是打印结果就是 6,6,6,6,6,6。
如何打印出符合预期的结果 将 let i = 0 写在for 循环里面即可
for(let i = 0; i&amp;lt;6; i++){ setTimeout(()=&amp;gt;{ console.log(i) },0) } // 0，1，2，3，4，5 其他方法 使用闭包，每次循环从外部把当时 i 的值传给 setClock，由 setClock 用当时的 i 的值设置定时器，最终输出 0,1,2,3,4,5</description>
    </item>
    
    <item>
      <title>JavaScript对象</title>
      <link>/post/javascript05/</link>
      <pubDate>Sat, 03 Apr 2021 18:00:00 +0000</pubDate>
      
      <guid>/post/javascript05/</guid>
      <description>JavaScript对象 JavaScript对象是七种数据类型中唯一一种复杂类型。
 是无序的数据集合 是键值对的集合  声明对象的写法 let obj = { &amp;#39;name&amp;#39;: &amp;#39;frank&amp;#39;, &amp;#39;age&amp;#39;: 18 } let obj = new Object({ &amp;#39;name&amp;#39;: &amp;#39;frank&amp;#39;}) 注意：
 键名是字符串，不是标识符，可以包含任意字符 引号可以省略，省略之后就只能写标识符 就算省略了引号，键名也还是字符串  变量做属性名 写法
let p1 = &amp;#39;name&amp;#39; let obj = {[p1]:&amp;#39;frank&amp;#39;} //属性名为&amp;#39;name&amp;#39; 对比
 不加 [] 的属性名会自动变成字符串 加了 [] 则会当作变量，先求值再变字符串 值如果不是字符串，则会自动变成字符串  对象的增删改查 删除属性 delete obj.xxx delete obj[&amp;#39;xxx&amp;#39;] //可删除 obj 的 xxx 属性（键和值）  obj.xxx = undefined //让 obj 的 xxx 属性值为 undefined，键还在 确认对象是否存在某个属性</description>
    </item>
    
    <item>
      <title>JavaScript的变量声明</title>
      <link>/post/javascript04/</link>
      <pubDate>Sat, 03 Apr 2021 14:00:00 +0000</pubDate>
      
      <guid>/post/javascript04/</guid>
      <description>JavaScript的变量声明 var a = 1 let a = 1 const a = 1  var 是过时的，不好用的方式 let 是新的，更合理的方式 const 声明时必须赋值且不能再改   一般用 let 声明变量， const 声明常量
 let声明  遵循块作用域，即使用范围为 {} 内部 不能重复声明 可以赋值，也可以不赋值 必须先声明，才能使用，否则报错 全局声明的 let 变量，不会变成 window 的属性，而 var 会创建 window 的属性 for 循环配合 let 有奇效  const声明  跟 let 几乎一样 声明时必须赋值，并且不能再改 for 循环不能使用 const， 因为 const 变量的值不能被修改  name 和 `name` 的区别  name 是变量，值可以是任何东西 `name` 是字符串常量，不会改变，只能是 `name`    资料来源：饥人谷</description>
    </item>
    
    <item>
      <title>JavaScript的数据类型</title>
      <link>/post/javascript03/</link>
      <pubDate>Sat, 03 Apr 2021 12:00:00 +0000</pubDate>
      
      <guid>/post/javascript03/</guid>
      <description>JavaScript的数据类型  数字 number 字符串 string 布尔 bool 符号 symbol 空 undefined 空 null 对象 object   注意：数组，函数，日期不是数据类型，都属于对象 object
 数字（64位浮点数） JS里数字的写法 JS里数字可以用以下几种写法来写：
1 //整数写法 0.1 //小数写法 1.23e4 //科学计数法 0123 或 00123 或 0o123 //八进制写法，较少 0x3F 或 0X3F //十六进制写法 0b11 或 0B11 //二进制写法 JS数字中的特殊值  正 0 和 负 0 不一样，但都等于 0 无穷大 Infinity +Infinity -Infinity 无法表示的数字 NaN（Not a Number），但它是一个数字  64位浮点数 浮点（floating point，缩写为FP）是一种对于实数的近似值数值表现法，由一个有效数字（尾数）加上幂数来表示，通常是乘以某个基数的整数次指数得到。以这种表示法表示的数值，称为浮点数（floating-point number）。
 例：123.456 可以表示为 1.23456e10^2</description>
    </item>
    
    <item>
      <title>JavaScript的基本语法</title>
      <link>/post/javascript02/</link>
      <pubDate>Sun, 21 Mar 2021 18:00:00 +0000</pubDate>
      
      <guid>/post/javascript02/</guid>
      <description>表达式与语句 表达式是一组代码的集合，它返回一个值。每一个合法的表达式都能计算成某个值，但从概念上讲，有两种类型的表达式：有副作用的（比如赋值）和单纯计算求值的。
JavaScript 的表达式类型  算数： 得出一个数字, 例如 3.14159 字符串： 得出一个字符串, 例如, &amp;ldquo;Fred&amp;rdquo; 或 &amp;ldquo;234&amp;rdquo; 逻辑值： 得出 true 或者 false 基本表达式： JavaScript 中基本的关键字和一般表达式 左值表达式： 分配给左值  例如：
1 + 2 //表达式的值是3  add(1, 2) //表达式的值为函数的返回值（只有函数才有返回值）  console.log //表达式的值为函数本身  console.log(3) //表达式的值是undefined JavaScript的语句 var a = 1 //就是一个语句 两者区别  表达式一般都有值，但语句可能有，也可能没有 语句一般会改变环境（声明、赋值）  注意   JS大小写敏感 只要不是断句的空格，就没有实际意义。可以任意加回车、空格 但是 return 后面不能加回车   标识符的规则  第一个字符，可以是 unicode字母 $ _ 中文 之后的字符可以是数字  if语句 语法 if (表达式) { 语句1; } else { 语句2; }  { }在语句只有一句的时候可以省略</description>
    </item>
    
    <item>
      <title>JavaScript初探</title>
      <link>/post/javascript01/</link>
      <pubDate>Sun, 21 Mar 2021 12:00:00 +0000</pubDate>
      
      <guid>/post/javascript01/</guid>
      <description>JavaScript是什么 JavaScript（通常缩写为 JS ）是一种高级的、解释型的编程语言。JavaScript 是一门基于原型、函数先行的语言，是一门多范式的语言，它支持面向对象程序设计，命令式编程，以及函数式编程。它提供语法来操控文本、数组、日期以及正则表达式等，不支持I/O，比如网络、存储和图形等，但这些都可以由它的宿主环境提供支持。它已经由 ECMA（欧洲电脑制造商协会）通过 ECMAScript 实现语言的标准化。它被世界上的绝大多数网站所使用，也被世界主流浏览器（Chrome、IE、Firefox、Safari、Opera）支持。
JavaScript 与 Java 在名字或语法上都有很多相似性，但这两门编程语言从设计之初就有很大的不同，JavaScript 的语言设计主要受到了 Self（一种基于原型的编程语言）和 Scheme（一门函数式编程语言）的影响。在语法结构上它又与C语言有很多相似（例如if条件语句、switch语句、while循环、do-while循环等）。
在客户端，JavaScript 在传统意义上被实现为一种解释语言，但在最近，它已经可以被即时编译（JIT）执行。随着最新的 HTML5 和 CSS3 语言标准的推行它还可用于游戏、桌面和移动应用程序的开发和在服务器端网络环境运行，如 Node.js。
为什么要发明JavaScript 1994年，网景公司（Netscape）发布了 Navigator 浏览器 0.9 版。这是历史上第一个比较成熟的网络浏览器，轰动一时。但是，这个版本的浏览器只能用来浏览，不具备与访问者互动的能力。比如，如果网页上有一栏&amp;quot;用户名&amp;quot;要求填写，浏览器就无法判断访问者是否真的填写了，只有让服务器端判断。如果没有填写，服务器端就返回错误，要求用户重新填写，这太浪费时间和服务器资源了。
网景公司当时有两个选择：
  一个是采用现有的语言，比如 Perl、Python、Tcl、Scheme 等等，允许它们直接嵌入网页 另一个是发明一种全新的语言。   这两个选择各有利弊。第一个选择，有利于充分利用现有代码和程序员资源，推广起来比较容易；第二个选择，有利于开发出完全适用的语言，实现起来比较容易。 到底采用哪一个选择，网景公司内部争执不下，管理层一时难以下定决心。
就在这时，发生了另外一件大事：1995年 Sun 公司将 Oak 语言改名为 Java，正式向市场推出。 Sun 公司大肆宣传，许诺这种语言可以 &amp;ldquo;一次编写，到处运行&amp;rdquo;（Write Once, Run Anywhere），它看上去很可能成为未来的主宰。网景公司动了心，决定与Sun公司结成联盟。它不仅允许 Java 程序以 applet（小程序）的形式，直接在浏览器中运行；甚至还考虑直接将 Java 作为脚本语言嵌入网页，只是因为这样会使HTML网页过于复杂，后来才不得不放弃。
总之，当时的形势就是，网景公司的整个管理层，都是 Java 语言的信徒，Sun 公司完全介入网页脚本语言的决策。因此，Javascript 后来就是网景和 Sun 两家公司一起携手推向市场的，这种语言被命名为 Java + script 并不是偶然的。
JavaScript的诞生 此时，34岁的系统程序员 Brendan Eich 登场了。Brendan Eich 的主要方向和兴趣是函数式编程，网景公司招聘他的目的，是研究将 Scheme 语言作为网页脚本语言的可能性。Brendan Eich 本人也是这样想的，以为进入新公司后，会主要与 Scheme 语言打交道。</description>
    </item>
    
  </channel>
</rss>
