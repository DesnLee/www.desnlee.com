[{"content":"什么是 this ？ 在说 call、apply 和 bind 之前，我们先来看看 Javascript 中的 this 是什么。\n先来看一段代码 ⬇️ ⬇️ ⬇️\nvar a = 1 const obj = { a: 2, fn: function() { console.log(this.a) } } const b = obj.fn obj.fn() // 2 b() // 1 上面代码中，虽然 obj.fn 和 b 指向同一个函数，但是执行结果不一样。这种差异的原因，就在于函数内使用了 this 关键字。 this 指的是函数运行时所在的环境。\n在内存图中，变量 obj 的值指向了一个地址，这个地址里保存了 a 和 fn ，而由于 fn 是一个函数，那么 fn 的值也是一个地址，在 fn 指向这个地址中保存了 fn 这个函数的函数体，所以这个函数是一个单独的值，那么他就可以在不同的环境中执行。\n obj的内存图  this 就指的是函数运行时的环境。\n 所以当运行 obj.fn() 时，fn() 的运行环境是 obj，所以这时候 this.a 就是 obj.a ； 当运行 b() 时，b() 的运行环境是 window，所以这时候 this.a 就是 window.a 。   由此得出，this 的值就是 . 前面的环境。\n call、apply 和 bind 了解了 this 之后，就可以说说 call、apply 和 bind 了。\ncall MDN对call的解释 -\u0026gt;\n MDN： call() 允许为不同的对象分配和调用属于一个对象的函数/方法。 call() 提供新的 this 值给当前调用的函数/方法。你可以使用 call 来实现继承：写一个方法，然后让另外一个新的对象来继承它（而不是在新对象中再写一次这个方法）。\n 通俗点讲就是，call 可以改变调用函数时的 this 值。以便我们可以在其他的地方调用同一个方法而不用再写一次该方法。\n了解了概念，那就看看怎么用吧。还是上面的代码，我们试着用 call 来调用它。\n//当我这样写的时候，得到的结果还是 2 obj.fn.call(obj) //2  //但是，当我这样写的时候，结果就和上面不同了 b.call(obj) //2 在调用 b() 的时候，使用 call 改变了 this 的指向，让他仍然指向 obj ，于是运行 b() 的结果没我们就得到了和 obj.fn() 一样的结果了。\n 总结一下 call 的用法：\nobj.fn.call(this, arg1, arg2)  call 的第一个参数是你要指定的 this，之后的参数就是函数自身的参数。\n apply MDN对apply的解释 -\u0026gt;\n call() 方法的作用和 apply() 方法类似，区别就是 call() 方法接受的是参数列表，而 apply() 方法接受的是一个参数数组。\n 直接来看用法吧：\nobj.fn.apply(this, [arg1, arg2])  apply 的第一个参数是你要指定的 this，之后的数组就是函数自身的参数组成的数组。\n bind MDN对bind的解释 -\u0026gt;\n bind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。\n bind() 返回一个原函数的拷贝，并拥有指定的 this 值和初始参数。\n还是上面的代码：\nlet c = obj.fn.bind(obj) c() //2 c.call(null) //2 c.call(obj) //2 我们让 c 等于 fn.bind(obj) 之后我们发现，使用 call 指定 c() 的 this 为任意对象，都不会改变运行结果。这就是因为bind() 返回一个原函数的拷贝，并拥有指定的 this 值和初始参数。\n他返回的是一个新函数， this 是创建时候指定的 this 值，并且不会被 call apply 等改变。\n与 call 和 apply 不同的是，上面两个在指定了 this 之后立即执行，而 bind 返回的是一个新的函数，在改变了函数的 this 的同时不会执行函数，可以在之后需要的时候再调用。\n  以上就是 this 、call 、 apply 和 bind 的简单讲解了。\n ","date":"2021-05-21T00:00:00Z","image":"/post/this/this_hu4886455551a131d8595f93ccd1eb8852_41492_720x720_fill_q75_box_smart1.jpg","permalink":"/post/this/","title":"this、call、apply 和 bind"},{"content":"闭包是什么？ 闭包： 是指有权访问另一个函数作用域中的变量的函数。\n闭包无处不在，比如 jQuery 、zepto 的核心代码都包含在一个大的闭包中。\n先来看一个闭包 ⬇️ ⬇️ ⬇️\nconst outSide = () =\u0026gt; { let a = 1 const inSide = () =\u0026gt; { a ++ console.log(a) } return inSide } const fn = outSide() fn() // 2 fn() // 3 fn() // 4 闭包的用途 闭包的实现原理，其实是利用了作用域链的特性。\n我们都知道作用域链就是在当前执行环境下访问某个变量时，如果不存在就向外层寻找，最终寻找到最外层也就是全局作用域，这样就形成了一个链条。\n隐藏变量，避免污染 在 Javascript 中，如果一个对象不再被引用，那么这个对象就会被 GC 回收，否则这个对象一直会保存在内存中。\n上面的代码，当函数 outSide 被执行后返回了函数 inSide ，函数inSide 的作用域链上有引用到函数 outSide 执行环境的变量 a，这个变量会被函数 fn 引用，所以 a 不会被垃圾回收机制处理掉，而是会留在内存中。这就形成了一个闭包。最后执行 fn() 依然能读取到变量 a。\n而如果不用闭包的话 ⬇️ ⬇️ ⬇️\nlet a = 1 const inSide = () =\u0026gt; { a ++ console.log(a) } inSide() // 2 如果我们再次调用 inSide() 时，结果会一直增加，相应的全局变量 a 的值一直递增。\ninSide() // 3 inSide() // 4 inSide() // 5 如果其他函数也需要使用这个变量 a ，那么 inSide 函数会改变 a 的值，使其他地方出错。而且全局变量容易被人修改，比较不安全。\n 所以，当我们需要在模块中定义一些变量，并希望这些变量一直保存在内存中但又不会 “污染” 全局的变量时，就可以用闭包来定义这个模块。\n 闭包的缺点 所以如果闭包使用不当，优点就变成了缺点\n 错误地使用闭包，导致无用的变量不会被垃圾回收机制回收，造成内存消耗； 过多/不恰当地使用闭包可能会造成内存泄漏的问题。  闭包应用对比 假如要对用户的某个数据实现一个自增需求，但又不能改变该用户本身的数据。\n 定义全局变量可以实现，但是会改变本身的 age  let age = 18 const fn = () =\u0026gt; { age ++ console.log(age) } fn()  定义局部变量，但实现不了递增  let age = 18 const fn = () =\u0026gt; { let age = 18 age ++ console.log(age) } fn()  闭包可以实现递增并且不污染全局变量  const age = 20 const outSide = () =\u0026gt; { let age = 18 return () =\u0026gt; { console.log(age++) } } const fn = outSide() fn() ","date":"2021-05-15T00:00:00Z","image":"/post/closure/closure_hu21628b3817d2300a5e695c2e226aa99e_133141_720x720_fill_q75_box_smart1.jpg","permalink":"/post/closure/","title":"JavaScript 的闭包（Closure）"},{"content":"什么是 DOM 事件 文档对象模型 （Document Object Model） 是 HTML 和 XML 文档的编程接口。\n它提供了对文档的结构化的表述，并定义了一种方式可以使从程序中对该结构进行访问，从而改变文档的结构，样式和内容。DOM 将文档解析为一个由节点和对象（包含属性和方法的对象）组成的结构集合。\n文档对象模型（DOM）提供了对同一份文档的另一种表现，存储和操作的方式。 DOM 是 web 页面的完全的面向对象表述，它能够使用如 JavaScript 等脚本语言进行修改。\n而事件是 JavaScript 与 HTML 交互的基础。要实现用户与页面的交互，先要通过 DOM 接口访问元素，再对目标元素绑定特定的事件、设置事件处理函数，然后用户触发事件，事件处理函数执行，产生交互效果。\nDOM 事件模型和事件流 事件流又称为事件传播，描述的是从页面中接收事件的顺序。当一个事件发生后，会在子元素和父元素之间传播（propagation）。这种传播分成三个阶段。\n 事件捕获阶段（capturing phase）： 事件从 window 对象自上而下向目标节点传播的阶段； 处于目标阶段（target phase）： 真正的目标节点正在处理事件的阶段； 事件冒泡阶段（bubbling phase）： 事件从目标节点自下而上向 window 对象传播的阶段。   在DOM2级事件流中，当我们点击下面的代码片段中的 div 元素后，在事件捕获阶段从上到下传播\n window \u0026ndash;\u0026gt; document -\u0026gt; html -\u0026gt; body \u0026ndash;\u0026gt; 目标\n \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt; 点我 \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 而事件冒泡的流程刚好是事件捕获的逆过程，冒泡和捕获的过程如下图：  DOM 事件流模型 \n下面来具体看看事件捕获和事件冒泡。\n事件捕获 Netscape 提出的事件流模型称为事件捕获。\n 事件从最不具体的节点开始接收（document），传递至最具体的节点 ，和 IE 的冒泡相反， 事件捕获的本意是当事件到达预定目标前捕获它。\n 当我们点击下面的代码片段中的 div 元素时，单击事件会按照如下顺序传播：\ndocument \u0026ndash;\u0026gt; html \u0026ndash;\u0026gt; body \u0026ndash;\u0026gt; div\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt; 点我 \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 事件冒泡 IE的事件流称为事件冒泡。\n 即：事件由最具体的元素接收(div)，逐级向上传播到不具体的节点(document)。\n 当我们点击下面的代码片段中的 div 元素时，单击事件会按照如下顺序传播：\ndiv \u0026ndash;\u0026gt; body \u0026ndash;\u0026gt; html \u0026ndash;\u0026gt; document\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt; 点我 \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 几乎现代所有的浏览器都支持事件冒泡，不过有一些细微的差别\n IE5.5 和 IE5.5 - 版本的事件冒泡会跳过 html 元素（body 直接到 document） IE9、Firefox、Chrome、Safari则一直冒泡到 window 对象。  事件委托/事件代理 传统的事件处理中，需要为每个元素添加事件处理器。而由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的代理（delegation）。\n事件代理的原理用到的就是事件冒泡和目标元素，把事件处理器添加到父元素，等待子元素事件冒泡，并且父元素能够通过 target（IE为 srcElement）判断是哪个子元素，从而做相应处理。\n事件代理的优点 \u0026gt; 减少内存消耗，提高性能 假设有一个列表，给每个列表项一一都绑定一个函数，那对于内存消耗是非常大的，效率上需要消耗很多性能。而将多个事件处理器减少到一个，因为事件处理器要驻留内存，这样就提高了性能。\n借助事件代理，我们只需要给父容器 ul 绑定方法即可，这样不管点击的是哪一个后代元素，都会根据冒泡传播的传递机制，把容器的绑定的事件触发，然后把对应的方法执行，根据事件源，我们可以知道点击的是谁，从而完成不同的事。\n\u0026gt; 动态绑定事件 在很多时候，我们需要通过用户操作动态的增删列表项元素，如果一开始给每个子元素绑定事件，那么在列表发生变化时，就需要重新给新增的元素绑定事件，给即将删去的元素解绑事件，如果用事件代理就会省去很多这样麻烦。\n事件绑定API //IE 5，冒泡（从小到大） div.attachEvent(`onclick`, fn) //网景，捕获（从大到小） div.addEventListener(`onclick`, fn) //W3C，先捕获再冒泡 div.addEventListener(`click`, fn, true) \u0026gt; addEventListener 的第三个参数 网景 和 微软 曾经的战争还是比较火热的，当时， 网景主张 捕获 方式，微软主张 冒泡 方式。后来 W3C 采用折中的方式，平息了战火，制定了统一的标准 —— 先捕获再冒泡。\n而 addEventListener 的第三个参数就是为冒泡和捕获准备的。 addEventListener有三个参数：\nelement.addEventListener(event, function(){}, useCapture) //第一个参数是需要绑定的事件 //第二个参数是触发事件后要执行的函数 //第三个参数不传或者为 falsy 表示在事件冒泡阶段调用事件处理函数;如果参数为true，则表示在事件捕获阶段调用处理函数。   资料来源：饥人谷、MDN、DOM事件机制\n ","date":"2021-05-01T02:00:00Z","image":"/post/dom01/dom1_hud97e667648a730b513b43e90f03dd833_30619_720x720_fill_q75_box_smart1.jpg","permalink":"/post/dom01/","title":"DOM 事件与事件委托"},{"content":"jQuery 简介 jQuery 是一套跨浏览器的 JavaScript 库，简化 HTML 与 JavaScript 之间的操作。\n据统计，全世界排名前 100 万的网站，有 76.85% 在使用 jQuery ，远远超过其他库（截止至2021年2月）。 点击查看统计数据 -\u0026gt;\n在 jQuery 诞生前，人们是使用原生 JS 来对 DOM 等一系列做操作的，但 JS 提供的 DOM API 有点反人类。\n因此，经过前端程序员们不断的努力和尝试，发明了现在这套经典的 JavaScript 函数库。\njQuery 常用操作 关于 jQuery 的全部 API，请查看 jQuery 中文文档，以下仅对常用的操作进行罗列。\n选择网页元素 jQuery 的基本设计思想和主要用法，就是 选择某个网页元素，然后对其进行某种操作。这是它区别于其他 Javascript 库的根本特点。\n使用 jQuery 的第一步，就是一个选择表达式，放进构造函数 jQuery()（简写为$），然后就可以对该元素进行操作了。\n选择表达式可以是 CSS 选择器，也可以是 jQuery 特有的表达式\n$(document) //选择整个文档  $(\u0026#39;#id\u0026#39;) //通过元素的 id 选择元素  $(\u0026#39;div.class\u0026#39;) // 通过 class 属性选择 div 元素  $(\u0026#39;input[name=name]\u0026#39;) // 通过 name 属性选择 input 元素  $(\u0026#39;a:first\u0026#39;) //选择网页中第一个 a 元素  $(\u0026#39;tr:odd\u0026#39;) //选择 tr 的奇数（odd）行  $(\u0026#39;#form :input\u0026#39;) // 选择表单中的 input 元素  $(\u0026#39;div:visible\u0026#39;) //选择可见（visible）的 div 元素  $(\u0026#39;div:gt(2)\u0026#39;) // 选择除了前三个余下的 div 元素，数字为下标  $(\u0026#39;div:animated\u0026#39;) // 选择当前处于动画状态的 div 元素 jQuery 设计思想之二，就是提供各种过滤器对结果集进行筛选进而缩小范围。\n$(\u0026#39;div\u0026#39;).has(\u0026#39;p\u0026#39;) // 选择包含 p 元素的 div 元素  $(\u0026#39;div\u0026#39;).not(\u0026#39;.class\u0026#39;) //选择 class 不为 class 的 div 元素  $(\u0026#39;div\u0026#39;).filter(\u0026#39;.class\u0026#39;) //选择 class 为 class 的 div 元素  $(\u0026#39;div\u0026#39;).first() //选择第 1 个 div 元素  $(\u0026#39;div\u0026#39;).eq(5) //选择第 6 个 div 元素，数字为下标  $(\u0026#39;div\u0026#39;).next(\u0026#39;p\u0026#39;) //选择 div 元素后面的第一个 p 元素  $(\u0026#39;div\u0026#39;).parent() //选择 div 元素的父元素  $(\u0026#39;div\u0026#39;).closest(\u0026#39;form\u0026#39;) //选择离 div 最近的 form 父元素  $(\u0026#39;div\u0026#39;).children() //选择 div 的子元素  $(\u0026#39;div\u0026#39;).siblings() //选择 div 的兄弟元素 链式操作 jQuery 设计思想之三，就是选中网页元素以后，可以对它进行一系列操作，所有操作可以连接在一起，以链条的形式写出来。\n这是 jQuery 最令人称道、最方便的特点。它的原理在于每一步的 jQuery 操作，返回的都是一个 jQuery 对象，该对象包含了所有 jQuery 操作，所以不同操作可以连在一起。\n比如：\n$(\u0026#39;div\u0026#39;).find(\u0026#39;h3\u0026#39;).eq(2).html(\u0026#39;Hello\u0026#39;) //在所有的 div 元素中，找到第 3 个 h3 元素，将其内容改为 Hello jQuery 还提供了 .end() 方法，使得结果集可以后退一步。该后退指的是选择元素的后退，并非指还原到上一步操作。\n$(\u0026#39;div\u0026#39;).find(\u0026#39;h3\u0026#39;).eq(2).html(\u0026#39;Hello\u0026#39;).end().eq(3).html(`World`) //在所有的 div 元素中，找到第 3 个 h3 元素，将其内容改为 Hello，然后退回到全部 h3 元素的结果集，选择第 4 个 h3 元素，将其内容改为 World 取值和赋值 jQuery 设计思想之四，就是使用同一个函数，来完成取值 getter 和赋值 setter，即 取值器 与 赋值器 合一。到底是取值还是赋值，由函数的参数决定。\n$(\u0026#39;h1\u0026#39;).html(); //直接调用函数，表示取出 h1 的值  $(\u0026#39;h1\u0026#39;).html(\u0026#39;Hello\u0026#39;); //给函数传入参数 Hello，表示对 h1 进行赋值 常见的取值和赋值函数如下：\n.html() //取出或设置 html 内容  .text() //取出或设置 text 内容  .attr() //取出或设置属性的值  .width() //取出或设置元素的宽度  .height() //取出或设置元素的高度  .val() //取出表单元素的值 需要注意的是\n 如果结果集包含多个元素，那么赋值的时候，将对其中 所有 的元素赋值\n取值的时候，则是只取出 第一个元素 的值\n.text() 例外，它会得到匹配元素集合中每个元素的合并文本，包括他们的后代\n 移动 jQuery 设计思想之五，就是提供两组方法，来操作元素在网页中的位置移动。\n一组方法是直接移动该元素，另一组方法是移动其他元素，使得目标元素达到我们想要的位置。\n 假定我们选中了一个 div 元素，需要把它移动到 p 元素后面。\n  第一种方法是使用 .insertAfter()，把 div 元素移动 p 元素后面  $(\u0026#39;div\u0026#39;).insertAfter($(\u0026#39;p\u0026#39;))  第二种方法是使用 .after()，把 p 元素加到 div 元素前面  $(\u0026#39;p\u0026#39;).after($(\u0026#39;div\u0026#39;)) 这两种方法有一个差别，那就是 返回的元素 不一样。\n第一种方法返回 div 元素，第二种方法返回 p 元素。可以根据需要，选择到使用哪一种方法。\n复制、删除和创建 除了元素的位置移动之外，jQuery 还提供其他几种操作元素的重要方法。\n 复制元素使用 .clone() 删除元素使用 .remove() 和 .detach() 。两者的区别在于，前者不保留被删除元素的事件，后者保留，有利于重新插入文档时使用。 清空元素内容（但是不删除该元素）使用 .empty()  创建新元素的方法非常简单，只要把新元素直接传入 jQuery 的构造函数\n$(\u0026#39;\u0026lt;p\u0026gt;Hello World\u0026lt;/p\u0026gt;\u0026#39;) $(\u0026#39;ul\u0026#39;).append(\u0026#39;\u0026lt;li\u0026gt;list item\u0026lt;/li\u0026gt;\u0026#39;) 工具方法 jQuery 设计思想之六,除了对选中的元素进行操作以外，还提供一些与元素无关的工具方法（utility）。不必选中元素，就可以直接使用这些方法。\n它是定义在 jQuery 构造函数上的方法，即 jQuery.method()，所以可以直接使用。\n而那些操作元素的方法，是定义在 jQuery 构造函数的 prototype 对象上的方法，即 jQuery.prototype.method()，所以必须生成实例（即选中元素）后使用。\n常用的工具方法有以下几种：\n$.trim() //去除字符串两端的空格  $.each() //遍历一个数组或对象  $.inArray() //返回一个值在数组中的索引位置。如果该值不在数组中，则返回-1  $.grep() //返回数组中符合某种标准的元素  $.extend() //将多个对象，合并到第一个对象  $.makeArray() //将对象转化为数组  $.type() //判断对象的类别（函数对象、日期对象、数组对象、正则对象等等）  $.isArray() //判断某个参数是否为数组  $.isEmptyObject() //判断某个对象是否为空（不含有任何属性）  $.isFunction() //判断某个参数是否为函数  $.isPlainObject() //判断某个参数是否为用\u0026#34;{}\u0026#34;或\u0026#34;new Object\u0026#34;建立的对象  $.support() //判断浏览器是否支持某个特性 事件操作 jQuery 设计思想之七，就是把事件直接绑定在网页元素之上。\n$(\u0026#39;p\u0026#39;).click( function () { alert(\u0026#39;Hello World\u0026#39;) } ) 查看 jQuery 全部事件操作 -\u0026gt;\n  资料来源：饥人谷、阮一峰的网络日志、jQuery API 中文文档\n ","date":"2021-04-29T00:00:00Z","image":"/post/jquery01/jquery_hu8ecff6ff9b6bcd20ee9d2ea60e2922b7_54313_720x720_fill_q75_box_smart1.jpg","permalink":"/post/jquery01/","title":"jQuery 常用操作手册"},{"content":"问题 有这么一段代码，打印的结果和预期不符\nlet i = 0 for(i = 0; i\u0026lt;6; i++){ setTimeout(()=\u0026gt;{ console.log(i) },0) } //6,6,6,6,6,6 预期的结果是打印出 0,1,2,3,4,5 ，但是执行的结果是 6,6,6,6,6,6\n分析 上面这段代码，用到了 setTimeout ，setTimeout 的作用是设置一个定时器，定时器到期后执行一个函数或指定的一段代码。\n上面的代码可以理解为：初始化 i 是 0，然后设置一个打印 i 的定时器，然后让 i 加 1，再次循环设置第二个定时器，直到 i 等于 6 则不再设置定时器，最后在退出 for 循环后，开始执行之前定的 6 个定时器。\n由于定时器执行是在for循环结束之后，所以当for 循环结束后，i 的值是 6， 这时候执行 6个定时器，定时器的内容是打印 i，于是打印结果就是 6,6,6,6,6,6。\n如何打印出符合预期的结果 将 let i = 0 写在for 循环里面即可\nfor(let i = 0; i\u0026lt;6; i++){ setTimeout(()=\u0026gt;{ console.log(i) },0) } // 0，1，2，3，4，5 其他方法 使用闭包，每次循环从外部把当时 i 的值传给 setClock，由 setClock 用当时的 i 的值设置定时器，最终输出 0,1,2,3,4,5\nlet i = 0 for(i = 0; i\u0026lt;6; i++){ function setClock(a){ setTimeout(()=\u0026gt;{ console.log(a) },0) } setClock(i) }   资料来源：饥人谷、MDN\n ","date":"2021-04-05T00:00:00Z","image":"/post/javascript06/js_function_hudc705b281e7f3aa7c988f4e75983e055_40234_720x720_fill_q75_box_smart1.jpg","permalink":"/post/javascript06/","title":"JavaScript函数的执行时机"},{"content":"JavaScript对象 JavaScript对象是七种数据类型中唯一一种复杂类型。\n 是无序的数据集合 是键值对的集合  声明对象的写法 let obj = { \u0026#39;name\u0026#39;: \u0026#39;frank\u0026#39;, \u0026#39;age\u0026#39;: 18 } let obj = new Object({ \u0026#39;name\u0026#39;: \u0026#39;frank\u0026#39;}) 注意：\n 键名是字符串，不是标识符，可以包含任意字符 引号可以省略，省略之后就只能写标识符 就算省略了引号，键名也还是字符串  变量做属性名 写法\nlet p1 = \u0026#39;name\u0026#39; let obj = {[p1]:\u0026#39;frank\u0026#39;} //属性名为\u0026#39;name\u0026#39; 对比\n 不加 [] 的属性名会自动变成字符串 加了 [] 则会当作变量，先求值再变字符串 值如果不是字符串，则会自动变成字符串  对象的增删改查 删除属性 delete obj.xxx delete obj[\u0026#39;xxx\u0026#39;] //可删除 obj 的 xxx 属性（键和值）  obj.xxx = undefined //让 obj 的 xxx 属性值为 undefined，键还在 确认对象是否存在某个属性\n\u0026#39;xxx\u0026#39; in obj === false //obj 不含 xxx 这个属性  \u0026#39;xxx\u0026#39; in obj \u0026amp;\u0026amp; obj.xxx === undefined //obj 有 xxx 这个属性，但是值为 undefined  obj.xxx === undefined //不能断定 \u0026#39;xxx\u0026#39; 是否为 obj 的属性 //因为可能属性有值，值为 undefined 读属性（查看） Object.keys(obj) //查看对象自身有的属性  Object.values(obj) //查看对象自身属性的值  Object.entries(obj) //查看对象自身的属性和值  console.dir(obj) //查看对象的共有属性  obj.hasOwnProperty(\u0026#39;key\u0026#39;) //查看对象自身有没有某个属性  obj[\u0026#39;key\u0026#39;] //查看属性的值，中括号语法 obj.key //查看属性的值，点语法 obj[key] //变量 key，要先求变量的值，再把值变成字符串 写属性（修改或增加） 直接赋值 let obj = {name: \u0026#39;frank\u0026#39;} //先创建变量  obj.name = \u0026#39;frank\u0026#39; obj[\u0026#39;name\u0026#39;] = \u0026#39;frank\u0026#39; obj[\u0026#39;na\u0026#39; + \u0026#39;me\u0026#39;] = \u0026#39;frank\u0026#39; //然后赋值，name是字符串，三种写法都可以  let key = \u0026#39;name\u0026#39; obj[key] = \u0026#39;frank\u0026#39; //也可以先创建一个变量 \u0026#39;name\u0026#39;，再赋值 批量赋值 Object.assign(obj,{p1:1,p2:2,p3:3}) //给 obj 创建三个属性同时赋值 无法在自身修改或增加共有属性，直接操作的共有属性会写在自己身上。如果想要修改共有属性，用下面的方法：\nObject.prototype.toString = \u0026#39;xxx\u0026#39; //把所有 Object 的隐藏属性 toString 改为 ‘xxx’ 对象的隐藏属性 每一个对象都有一个隐藏属性，这个隐藏属性储存着对象的 共有属性组成的对象的地址，这个共有属性组成的对象就是 原型。\n原型 每个对象都有原型，原型里存着对象的共有属性，obj.__proto__ 存着共有属性组成的对象的地址，这个对象里有 toString constructor valueOf 等共有属性。\n对象的原型也是对象，obj = {} 的原型即为所有对象的原型，这个原型包含所有对象的共有属性，是对象的根，对象的根这个原型也有原型，值为 null\n原型链 let obj = Object.create(xxx) obj.name = \u0026#39;frank\u0026#39; //以 xxx 这个对象作为 obj 的原型创建 obj 对象,然后给 obj 创建name属性并赋值  let obj = Object.create(xxx,{ name:{value:\u0026#39;frank\u0026#39;}\t}) //以 xxx 这个对象作为 obj 的原型创建 obj 对象同时增加属性并赋值 这样创建的 obj 的原型是xxx，而xxx 的原型是对象的原型，这样就形成了一个原型链。\n细节 Q：'name' in obj 和 obj.hasOwnProperty('name') 的区别\nA：这两种方法都可以查看 obj 是否含有 'name'属性，返回值为 true 或 false，他们两个区别是 hasOwnProperty 仅仅判断 obj本身的属性是否含有 'name'，而 in也会去对象的原型里去找是否含有该属性。\n MDN文档：所有继承了 Object 的对象都会继承到 hasOwnProperty 方法。这个方法可以用来检测一个对象是否含有特定的自身属性；和 in 运算符不同，该方法会 忽略掉那些从原型链上继承到的属性。\n   资料来源：饥人谷、MDN\n ","date":"2021-04-03T18:00:00Z","permalink":"/post/javascript05/","title":"JavaScript对象"},{"content":"JavaScript的变量声明 var a = 1 let a = 1 const a = 1  var 是过时的，不好用的方式 let 是新的，更合理的方式 const 声明时必须赋值且不能再改   一般用 let 声明变量， const 声明常量\n let声明  遵循块作用域，即使用范围为 {} 内部 不能重复声明 可以赋值，也可以不赋值 必须先声明，才能使用，否则报错 全局声明的 let 变量，不会变成 window 的属性，而 var 会创建 window 的属性 for 循环配合 let 有奇效  const声明  跟 let 几乎一样 声明时必须赋值，并且不能再改 for 循环不能使用 const， 因为 const 变量的值不能被修改  name 和 `name` 的区别  name 是变量，值可以是任何东西 `name` 是字符串常量，不会改变，只能是 `name`    资料来源：饥人谷\n ","date":"2021-04-03T14:00:00Z","permalink":"/post/javascript04/","title":"JavaScript的变量声明"},{"content":"JavaScript的数据类型  数字 number 字符串 string 布尔 bool 符号 symbol 空 undefined 空 null 对象 object   注意：数组，函数，日期不是数据类型，都属于对象 object\n 数字（64位浮点数） JS里数字的写法 JS里数字可以用以下几种写法来写：\n1 //整数写法 0.1 //小数写法 1.23e4 //科学计数法 0123 或 00123 或 0o123 //八进制写法，较少 0x3F 或 0X3F //十六进制写法 0b11 或 0B11 //二进制写法 JS数字中的特殊值  正 0 和 负 0 不一样，但都等于 0 无穷大 Infinity +Infinity -Infinity 无法表示的数字 NaN（Not a Number），但它是一个数字  64位浮点数 浮点（floating point，缩写为FP）是一种对于实数的近似值数值表现法，由一个有效数字（尾数）加上幂数来表示，通常是乘以某个基数的整数次指数得到。以这种表示法表示的数值，称为浮点数（floating-point number）。\n 例：123.456 可以表示为 1.23456e10^2\n 64浮点数的存储格式  符号占1位，指数占11位（-1023 ～ 1024） 有效数字占52位（开头的1省略）   浮点数的存储格式 \n字符串 写法 \u0026#34;\u0026#34; //双引号 \u0026#39;\u0026#39; //单引号 `` //反引号  //字符串需要包含引号时用转义符 \\ //反引号内可以直接换行，直接使用引号 // 用反引号比较万能，尽量使用反引号 属性 string.length //字符串长度 string[0] //字符串的第一个字符，顺延+1，以此类推 数字与字符串的区别 区别点 功能不同：\n 数字是数字，字符串是字符串 数字能加减乘除，字符串不行 字符串能表示电话号码，数字不行  储存形式不同：\n 数字是用 64 位浮点数的形式存储的 字符串是用类似 UTF-8 形式存储的（UCS-2）  如何存  存数字： 十进制转二进制即可 存字符串： 用编码对应，存编号  布尔 布尔（Boolean）是计算机科学中的逻辑数据类型，以发明布尔代数的数学家 乔治·布尔 为名。 它是只有两种值的原始类型，通常是 真 和 假。 布尔数据类型主要与条件语句相关系，条件语句通过根据开发人员指定的条件式，更改程序控制流来允许评估语句的运算值为真或假(即条件成立或不成立)。\n什么运算可以得到bool值 !value //否定运算 1 == 2 //相等运算 1 \u0026gt; 2 //比较运算 五个 falsy 值 undefined null 0 NaN ''\n两种空类型 undefined 和 null没有本质区别\n 如果一个变量声明了，但是没有赋值，那么默认值就是 undefined 而不是 null 如果一个函数，没有写 return ，那么默认 return 的是 undefined 而不是 null 习惯上把非对象的空值写为 undefined，把对象的空值写为 null  symbol symbol不常用，可以查看知乎的文章了解一下。\n「每日一题」JS 中的 Symbol 是什么？ -\u0026gt;\n数据类型的转换 number ⇒ string String(n) n + `` string ⇒ number Number(s) s - 0 +s parseInt(\u0026#39;123\u0026#39;) x ⇒ bool Boolean(x) !!x x ⇒ string x.toString() 1..toString() (1).toString() //如果转换数字用两个 . 或者给数字加括号   资料来源：饥人谷、WikiPedia\n ","date":"2021-04-03T12:00:00Z","permalink":"/post/javascript03/","title":"JavaScript的数据类型"},{"content":"表达式与语句 表达式是一组代码的集合，它返回一个值。每一个合法的表达式都能计算成某个值，但从概念上讲，有两种类型的表达式：有副作用的（比如赋值）和单纯计算求值的。\nJavaScript 的表达式类型  算数： 得出一个数字, 例如 3.14159 字符串： 得出一个字符串, 例如, \u0026ldquo;Fred\u0026rdquo; 或 \u0026ldquo;234\u0026rdquo; 逻辑值： 得出 true 或者 false 基本表达式： JavaScript 中基本的关键字和一般表达式 左值表达式： 分配给左值  例如：\n1 + 2 //表达式的值是3  add(1, 2) //表达式的值为函数的返回值（只有函数才有返回值）  console.log //表达式的值为函数本身  console.log(3) //表达式的值是undefined JavaScript的语句 var a = 1 //就是一个语句 两者区别  表达式一般都有值，但语句可能有，也可能没有 语句一般会改变环境（声明、赋值）  注意   JS大小写敏感 只要不是断句的空格，就没有实际意义。可以任意加回车、空格 但是 return 后面不能加回车   标识符的规则  第一个字符，可以是 unicode字母 $ _ 中文 之后的字符可以是数字  if语句 语法 if (表达式) { 语句1; } else { 语句2; }  { }在语句只有一句的时候可以省略\n 注意  表达式里可以非常变态，如 a = 1 语句1 和 语句2 里可以嵌套 if else 注意缩进及省略 { } 的情况  switch语句 switch (fruit) { case \u0026#34;banana\u0026#34;: //...  break; case \u0026#34;apple\u0026#34;: //...  break; default: //... } // break 不能省略，除非需要判断多个条件 问号冒号表达式（三元表达式） 表达式1 ? 表达式2 : 表达式3 //如果表达式1成立，返回表达式2，否则返回表达式3 //if else 各只有一句的时候可以用问号冒号表达式简化 \u0026amp;\u0026amp;短路逻辑 和 ||短路逻辑 A \u0026amp;\u0026amp; B \u0026amp;\u0026amp; C \u0026amp;\u0026amp; D //取第一个为假的值，如果都为真则取最后一个值，并不会取 true / false //也是用来代替 if else 语句  例: fn \u0026amp;\u0026amp; fn() //如果 fn 存在，就调用 fn  A || B || C || D //取第一个为真的值，如果都为假则取最后一个值，并不会取 true / false //也是用来代替 if else 语句  例: A = A || B //如果 A 不存在，则 A = B，B 是 A 的保底值 循环 while循环 var a =1 //初始化 while (表达式) { //判断  语句 //循环体  a = a +0.1 //增长 } // 1.判断表达式的真假 // 2.表达式为真，执行语句，执行完再返回判断表达式的真假 // 3.表达式为假，跳出循环，执行花括号后面的语句 for循环 for(语句1;表达式2;语句3){ 循环体 } // 1.先执行语句1 // 2.然后判断表达式2 // 3.如果为真，执行循环体，然后执行语句3 // 4.如果为假，跳出循环，执行花括号后面的语句 break 和 continue  break 退出当前所有循环 continue 退出当前这一次循环  label foo: { //标识符 console.log(1) //花括号内打印 1 break foo; //跳出 console.log(2); //花括号内打印 2 } console.log(3) //花括号外打印 3  // 结果只会打出 1 和 3 ，因为在打印 2 之前使用了 break 跳出   资料来源：饥人谷、WikiPedia\n ","date":"2021-03-21T18:00:00Z","permalink":"/post/javascript02/","title":"JavaScript的基本语法"},{"content":"JavaScript是什么 JavaScript（通常缩写为 JS ）是一种高级的、解释型的编程语言。JavaScript 是一门基于原型、函数先行的语言，是一门多范式的语言，它支持面向对象程序设计，命令式编程，以及函数式编程。它提供语法来操控文本、数组、日期以及正则表达式等，不支持I/O，比如网络、存储和图形等，但这些都可以由它的宿主环境提供支持。它已经由 ECMA（欧洲电脑制造商协会）通过 ECMAScript 实现语言的标准化。它被世界上的绝大多数网站所使用，也被世界主流浏览器（Chrome、IE、Firefox、Safari、Opera）支持。\nJavaScript 与 Java 在名字或语法上都有很多相似性，但这两门编程语言从设计之初就有很大的不同，JavaScript 的语言设计主要受到了 Self（一种基于原型的编程语言）和 Scheme（一门函数式编程语言）的影响。在语法结构上它又与C语言有很多相似（例如if条件语句、switch语句、while循环、do-while循环等）。\n在客户端，JavaScript 在传统意义上被实现为一种解释语言，但在最近，它已经可以被即时编译（JIT）执行。随着最新的 HTML5 和 CSS3 语言标准的推行它还可用于游戏、桌面和移动应用程序的开发和在服务器端网络环境运行，如 Node.js。\n为什么要发明JavaScript 1994年，网景公司（Netscape）发布了 Navigator 浏览器 0.9 版。这是历史上第一个比较成熟的网络浏览器，轰动一时。但是，这个版本的浏览器只能用来浏览，不具备与访问者互动的能力。比如，如果网页上有一栏\u0026quot;用户名\u0026quot;要求填写，浏览器就无法判断访问者是否真的填写了，只有让服务器端判断。如果没有填写，服务器端就返回错误，要求用户重新填写，这太浪费时间和服务器资源了。\n网景公司当时有两个选择：\n  一个是采用现有的语言，比如 Perl、Python、Tcl、Scheme 等等，允许它们直接嵌入网页 另一个是发明一种全新的语言。   这两个选择各有利弊。第一个选择，有利于充分利用现有代码和程序员资源，推广起来比较容易；第二个选择，有利于开发出完全适用的语言，实现起来比较容易。 到底采用哪一个选择，网景公司内部争执不下，管理层一时难以下定决心。\n就在这时，发生了另外一件大事：1995年 Sun 公司将 Oak 语言改名为 Java，正式向市场推出。 Sun 公司大肆宣传，许诺这种语言可以 \u0026ldquo;一次编写，到处运行\u0026rdquo;（Write Once, Run Anywhere），它看上去很可能成为未来的主宰。网景公司动了心，决定与Sun公司结成联盟。它不仅允许 Java 程序以 applet（小程序）的形式，直接在浏览器中运行；甚至还考虑直接将 Java 作为脚本语言嵌入网页，只是因为这样会使HTML网页过于复杂，后来才不得不放弃。\n总之，当时的形势就是，网景公司的整个管理层，都是 Java 语言的信徒，Sun 公司完全介入网页脚本语言的决策。因此，Javascript 后来就是网景和 Sun 两家公司一起携手推向市场的，这种语言被命名为 Java + script 并不是偶然的。\nJavaScript的诞生 此时，34岁的系统程序员 Brendan Eich 登场了。Brendan Eich 的主要方向和兴趣是函数式编程，网景公司招聘他的目的，是研究将 Scheme 语言作为网页脚本语言的可能性。Brendan Eich 本人也是这样想的，以为进入新公司后，会主要与 Scheme 语言打交道。\n仅仅一个月之后，1995年5月，网景公司做出决策，未来的网页脚本语言必须\u0026quot;看上去与 Java 足够相似\u0026quot;，但是比 Java 简单，使得非专业的网页作者也能很快上手。这个决策实际上将 Perl、Python、Tcl、Scheme 等非面向对象编程的语言都排除在外了。\nBrendan Eich 被指定为这种 \u0026ldquo;简化版Java语言\u0026rdquo; 的设计师。 但是，他对 Java 一点兴趣也没有。为了应付公司安排的任务，他只用 10 天时间就把 JavaScript 设计出来了。他觉得，没必要设计得很复杂，这种语言只要能够完成一些简单操作就够了，比如判断用户有没有填写表单。\n 总的来说，他的设计思路是这样的：\n  借鉴 C 语言的基本语法； 借鉴 Java 语言的数据类型和内存管理； 借鉴 Scheme 语言，将函数提升到\u0026quot;第一等公民\u0026quot;（first class）的地位； 借鉴 Self 语言，使用基于原型（prototype）的继承机制。   所以，JavaScript 语言实际上是两种语言风格的混合产物 \u0026mdash;-（简化的）函数式编程+（简化的）面向对象编程。这是由 Brendan Eich（函数式编程）与网景公司（面向对象编程）共同决定的。\nJavaScript的标准化 1996年11月，网景正式向 ECMA（欧洲计算机制造商协会）提交语言标准。\n1997年6月，ECMA 以 JavaScript 语言为基础制定了 ECMAScript 标准规范ECMA-262。JavaScript 成为了 ECMAScript 最著名的实现之一。\n  资料来源：饥人谷、阮一峰的网络日志、WikiPedia\n ","date":"2021-03-21T12:00:00Z","image":"/post/javascript01/javascript_hua450a9c4244e2ee1d7363c98cdd5b5cc_70970_720x720_fill_q75_box_smart1.jpg","permalink":"/post/javascript01/","title":"JavaScript初探"},{"content":"URL是什么 Uniform Resource Locator（URL，统一资源定位符），俗称网址，是因特网上标准的资源的地址。由 蒂姆·伯纳斯-李 发明用来作为万维网的地址。\n它使用美国信息交换标准代码的一部分来表示因特网的地址。统一资源定位符的开始，一般会标志着一个计算机网络所使用的网络协议。\nURL的组成 统一资源定位符的标准格式：\n [ 协议类型 ] :// [ 服务器地址 ] : [ 端口号 ] / [ 资源层级UNIX文件路径 ] [ 文件名 ] ? [ 查询 ] # [ 片段ID ]\n 一个完整的URL\n https://www.google.com:443/search?q=hello#botstuff\n 其中：\n https 协议，告诉浏览器这次请求使用什么协议交流，常见的有 http、https、file、ftp等。 www.google.com 域名，浏览器会从 DNS 结果找到域名对应服务器 IP 地址，向该服务器发送本次请求。 443 端口号，告诉服务器本次请求的是哪个端口的服务。 /search 路径，告诉服务器本次请求的是哪里的内容。 q=hello 查询参数，每个参数以“\u0026amp;”隔开，告诉服务器本次请求想要的结果是什么 botstuff 片段 ID，浏览器本地处理，将页面直接定位到 ID 为 botstuff 的元素位置。片段 ID 不会跟着请求一起发送给服务器。   总结：\n 协议是告诉浏览器怎么发请求 域名/IP地址是告诉浏览器找谁请求 端口号是告诉请求的对象我要请求哪个服务 路径是告诉请求的对象我要请求该端口下什么位置的内容 查询参数是告诉请求的对象我对查询结果的限制条件是什么   那么DNS是什么 Domain Name System（DNS，域名系统），是互联网的一项服务。它是一个将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。\n通俗来讲，DNS 就像以前的 114 查询台，DNS 存储了很多的域名和 IP 的映射表，我们在浏览器输入的域名，浏览器并不知道他需要访问哪一台设备，所以需要一个 DNS 服务器来告诉浏览器这个域名对应的设备 IP，浏览器获取到设备 IP 后通过 IP 去访问对应的主机。\n如何查询域名对应的IP $ nslookup 域名 DNS服务器地址 使用 nslookup 命令，可以看到域名对应的 IP 地址，不加 DNS 服务器地址则是向默认 DNS 服务器查询，加上的话是向指定的 DNS 服务器查询。\n什么是IP IP Address，是网际协议（Internet Protocol）中用于标识发送或接收数据报的设备的一串数字。\n当设备连接网络，设备将被分配一个 IP 地址，用作标识。通过 IP 地址，设备间可以互相通讯，如果没有 IP 地址，我们将无法知道哪个设备是发送方，无法知道哪个是接收方。IP 地址有两个主要功能：标识设备或网络 和 寻址（location addressing）。\nIP 地址分为 IPv4 和IPv6 两类：\n IPv4 由十进制数字组成，如 192.168.0.1 IPv6 由十六进制数组成，如 2001:db8:0:1234:0:567:8:1  IP 地址有两个主要的功能：\n 标识主机： 更具体地说，标识其网络接口，并且提供主机在网络中的位置。 网络寻址： 该功能是将 数据报 从一个网络模块 送到 目的地。在发送的整个过程，IP地址（address）充当着目的地的位置，域名（name）意味着我们要找什么，路由（route）代表着如何到达目的地的这个过程。每个 IP 数据包的标头包含了发送主机的 IP 地址和目的主机的 IP 地址。  Ping是什么 $ ping 域名 Ping 是一种计算机网络工具，可以用来测试数据包能否透过 IP 协议到达特定主机。Ping 的运作原理是向目标主机传出一个 ICMP 的请求回显数据包，并等待接收回显回应数据包。程序会按时间和成功响应的次数估算丢失数据包率（丢包率）和数据包往返时间（网络时延，Round-trip delay time）。\n域名 网域名称（Domain Name），简称域名、网域，是由一串用点分隔的字符组成的互联网上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位。\n域名可以说是一个 IP 地址的代称或别名，目的是为了便于记忆。例如 wikipedia.org 是一个域名，人们可以直接访问 wikipedia.org 来代替 IP 地址，然后域名系统 DNS 就会将它转化成便于机器识别的IP地址。这样，人们只需要记忆 wikipedia.org 这一串带有特殊含义的字符，而不需要记忆没有含义的数字。\n域名的核心是域名系统（Domain Name System，DNS），域名系统中的任何名称都是域名。在域名系统的层次结构中，各种域名都隶属于域名系统根域的下级。\n 域名的第一级是顶级域，它包括通用顶级域，例如 .com .net 和 .org 等等 顶级域名下一层是二级域名，例如 baidu.com， github.io 等等 二级域名下面是三级域名，例如 tieba.baidu.com ， username.github.io 等等 顶级域名的管理服务由对应的域名注册管理机构（域名注册局）负责，注册服务通常由域名注册商负责。    资料来源：饥人谷、WikiPedia\n ","date":"2021-03-19T00:00:00Z","image":"/post/url01/url_hudcce9b6e22cdca329770ba899599193c_91552_720x720_fill_q75_box_smart1.jpg","permalink":"/post/url01/","title":"浅析 URL"},{"content":"CSS布局是什么 布局是把页面分成一块一块，按左中右、上中下等排列。\n 固定宽度布局： 一般 960px、1000px、1024px 等宽度。 不固定宽度布局： 主要靠文档流的原理布局。 响应式布局： PC上固定宽度，移动端不固定宽度，也就是混合布局。   布局的两种思路\n从大到小——先定下大局，然后完善每个部分的小布局。\n从小到大——先完成小布局，然后组合成大布局。\n CSS布局之——Float浮动布局 float 属性指定一个元素应沿其容器的左侧或右侧放置，允许文本和内联元素环绕它。该元素将从网页的正常流动(文档流)中移除。\n当一个元素浮动之后，它会被移出正常的文档流，然后向左或者向右平移，一直平移直到碰到了所处的容器的边框，或者碰到另外一个浮动的元素。\n最早是为了图文混排，兼容 IE 则需 float 布局，否则可直接用 flex 或者 grid 布局，其更加强大。\n具体使用方式参考 MDN 文档 -\u0026gt;\nCSS布局之——Flex弹性布局 flex 属性设置了弹性项目如何增大或缩小以适应其弹性容器中可用的空间。 此方案为目前网页主流布局方式。\n具体使用方式参考 MDN 文档 -\u0026gt;\nCSS布局之——Grid网格布局 grid 属性定义了一个 CSS 网格。接着就可以使用属性给网格划分区域，然后就可以在这些网格中自由选择区域放置内容，称为网格布局。网格布局比 flex 弹性布局更加强大，但目前此方案浏览器兼容性比较差。\n具体使用方式参考 MDN 文档 -\u0026gt;\n浏览器渲染原理 浏览器拿到一个网页的文件后，依次做出以下的处理，然后浏览器就可以显示出网页渲染后的样子：\n  根据HTML构建HTML树（DOM） 根据CSS构建CSS树（CSSOM） 将两棵树合并成一棵渲染树（render tree） Layout 布局（文档流、盒模型、计算大小和位置） Paint 绘制（把边框颜色、文字颜色、阴影等画出来） Composite 合成（根据层叠关系展示画面）   CSS动画及性能优化 通过更新元素的CSS属性，使得元素有变化，就是一个CSS动画。三种更新方式为：\n 更新 Layout，整个页面布局 relayout，从第 4 步开始将页面重新渲染一次。 更新 Paint，将元素的 paint 属性更新，从第 5 步开始将页面重新渲染一次。 更新 Composite，仅仅只需重走第 6 步。  依据上面的渲染原理可得出，改变的属性在浏览器渲染步骤中越靠后，浏览器重新渲染所需的步骤资源就越少，性能就越好。\n 例如使用 will-change 或 translate\n CSS动画的实现方式 transform（变形） \u0026amp; transition（过渡） transform 属性允许你旋转，缩放，倾斜或平移给定元素。这是通过修改CSS视觉格式化模型的坐标空间来实现的。\ntransition 属性可以被指定为一个或多个 CSS 属性的过渡效果。\n通过 transform 属性，设置一个触发条件，然后为元素分别设置触发前后的状态，最后给元素加上 transition 属性让浏览器自动补充中间帧来过渡，达到触发加载动画的效果。\ntransform 使用方式参考 MDN 文档 -\u0026gt;\ntransition 使用方式参考 MDN 文档 -\u0026gt;\n但是，并不是所有的属性都能过渡\nanimation 通过 @keyframes 语法添加关键帧，然后用 animation 把关键帧赋予元素，使该元素依照 @keyframe 定义的行为运动。\ntransition 使用方式参考 MDN 文档 -\u0026gt;\n  资料来源：饥人谷、MDN\n ","date":"2021-03-18T14:00:00Z","image":"/post/css02/animation_hu13aa786e8975fa6207722c36a94e461f_60542_720x720_fill_q75_box_smart1.jpg","permalink":"/post/css02/","title":"CSS布局及动画"},{"content":"CSS是什么 层叠样式表（Cascading Style Sheets，简称：CSS），是一种用来为结构化文档（如HTML文档或XML应用）添加样式（字体、间距和颜色等）的计算机语言，由W3C定义和维护。CSS不能单独使用，必须与HTML或XML一起协同工作，为HTML或XML起装饰作用。\nCSS最重要的目标是将文件的内容与它的显示分隔开来。在CSS出现前，几乎所有的HTML文件内都包含文件显示的信息，必须在HTML文件内列出，有时重复列出。CSS使作者可以将这些信息中的大部分隔离出来，简化HTML文件，这些信息被放在一个辅助的，用CSS语言写的文件中。HTML文件中只包含结构和内容的信息，CSS文件中只包含样式的信息。\nCSS的历史  CSS1： 1994年，哈肯·维姆·莱和伯特·波斯合作设计CSS。他们在1994年首次在芝加哥的一次会议上第一次展示了CSS的建议。 CSS2-2.1： 1998年5月，W3C发表了CSS2，其中包括新的内容如： 绝对的、相对的和固定的定比特素、媒体型的概念、 双向文件和一个新的字体。 CSS3： CSS3标准已部分公布，但仍未全部制订完毕，还会有其它新内容继续加入。W3C网站上有专页展示CSS3发展的进展。CSS3分成了不同类别，称为 modules 。而每一个 modules 都有于CSS2中额外增加的功能，以及向后兼容。  CSS的语法内容 CSS由多组 规则 组成。每个规则由 选择器（selector）、属性（property） 和 值（value） 组成：\n 选择器（Selector）： 多个选择器可以半角逗号 , 隔开。 属性（property）： CSS1、CSS2、CSS3规定了许多的属性，目的在控制选择器的样式。 值（value）： 指属性接受的设置值，多个关键字时大都以空格隔开。  属性和值之间用半角冒号 : 隔开，属性和值合称为 特性。多个特性间用 ; 隔开，最后用 { } 括起来。\n示例：\np/*选择器*/{ font-size/*属性*/: 110%;/*值*/ font-size: 110%; } CSS的层叠指的是什么？  样式层叠： 可以多次对同一选择器进行样式声明。 选择器层叠： 可以用不同选择器对同一个元素进行样式声明。 文件层叠： 可以用多个文件进行层叠。  文档流 Normal Flow，正常流动方向。文档流方向为从左到右，从上到下。\n  块级元素（block） 总是占据水平方向上所有的空间（能有多大就多大），多个块元素从上到下流动。\n  内联元素（inline） 仅占据自身大小（能有多小就多小），多个内联元素从左到右流动。\n  盒模型 编写 CSS 时你会发现，你的工作好像是围绕着一个一个盒子展开的——设置尺寸、颜色、位置，等等。页面里大部分 HTML 元素都可以被看作若干层叠的盒子。CSS 布局主要就是基于盒模型的。每个占据页面空间的块都有这样的属性：\n content： 即内容本身。 padding： 即内边距，围绕着内容（比如段落）的空间。 border： 即边框，紧接着内边距的线。 margin： 即外边距，围绕元素外部的空间。  两种盒模型  content-box： 内容盒，内容就是盒子的边界。 border-box： 边框盒，边框是盒子的边界。   两种盒子组成部分均为 margin + border + padding + content\n content-box 的设置的宽度 = 内容宽度 border-box 的设置的宽度 = 内容宽度 + padding + border   CSS基本单位  长度单位： px像素、em相对于自身font-size的倍数、% 百分数、整数、rem、vw 和 vh、其他。 颜色： 十六进制 #FFFFFF 、RGBA颜色 rgba(255,255,255,1) 、hsl颜色 hsl(360,100%,100%)    资料来源：饥人谷、MDN、WikiPedia\n ","date":"2021-03-18T12:00:00Z","image":"/post/css01/css_hu763ae0ba2371867e65fcd855d09be547_33178_720x720_fill_q75_box_smart1.jpg","permalink":"/post/css01/","title":"CSS基础概述"},{"content":"a 标签 HTML \u0026lt;a\u0026gt; 元素（或称锚元素）可以创建通向其他网页、文件、同一页面内的位置、电子邮件地址或任何其他 URL 的超链接。\n\u0026lt;a\u0026gt; 标签的属性  Download (HTML5的属性)： 该属性告诉浏览器是下载该 URL 的文件。如果属性有值，那么此值将在下载保存过程中作为预填充的文件名（如果用户需要，仍然可以更改文件名）。 href： 包含超链接指向的 URL 或 URL 片段。URL 不限于基于 Web（HTTP）的文档，也可以使用浏览器支持的任何协议。 rel： 该属性指定了目标对象到链接对象的关系。该值是空格分隔的列表类型值。 target： 该属性指定在何处显示链接的资源。 取值为标签tab，窗口window，或框架iframe等浏览上下文的名称或其他关键词。  href取值  http协议地址： http://google.com/ https协议地址： https://google.com/ 无协议网址： //google.com/ 此地址会继承当前页面的协议。 绝对路径和相对路径： /a/b/c 或 a/b/c 这个绝对路径的根目录指的是当前服务的根目录。 文件名： index.html 或 ./index.html 当前目录的 index.html 文件。 JavaScript伪协议： javascript:alert(1);  点击执行JS事件。通常达成想要点击 a 标签什么事情都不做的需求，其他任何属性都无法达到。 元素id名： 若 xxx 为某个元素的 id 名，点击 a 标签则跳转到 id=\u0026quot;xxx\u0026quot; 的元素位置，通常用来做锚点。 邮件协议： mailto:abc@qq.com 点击调起邮箱APP向该邮箱发送邮件。 电话协议： tel:13313133131 点击调起电话APP向该电话拨号。  target取值  _blank 在新页面打开链接。 _top 在顶层页面打开链接。通常需要嵌套 \u0026lt;iframe\u0026gt; 才可以体现出来。 _parent 在父级页面打开链接。通常需要嵌套两层 \u0026lt;iframe\u0026gt; 才可以和 _top 区分开来。 _self 在当前页面打开链接。默认属性，如未赋值则默认为 self。 xxx（页面名） 在名为 xxx 的页面打开链接。若无名为 xxx 的页面则创建一个。  img 标签 HTML\u0026lt;img\u0026gt;元素将一份图像嵌入文档。用来发出一个GET请求，获取并展示一个图片。\n\u0026lt;img\u0026gt; 标签的属性  src： 该属性表示了想要嵌入的图片的路径，是必须的属性。 alt： 包含一条对图片的描述文字。如果图片加载失败，则展示 alt 的内容，可提升用户体验。 height 和 width：该属性表示图片的宽和高，指定一项，另一项则等比例自适应，尽量不要两个同时设置。  \u0026lt;img\u0026gt; 标签的事件  onload： 当图片加载成功时会触发该事件。 onerror： 当图片加载失败时会触发该事件。可以通过 JS 使图片加载失败时加载一个 404 图片。  table 标签 HTML \u0026lt;table\u0026gt; 元素表示表格数据。\n\u0026lt;table\u0026gt; 相关的标签  thead： 表示表格的头部。内部为 \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; tbody： 表示表格的内容。内部为 \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; tfoot： 表示表格的底部。内部为 \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt;   注：thead 、tbody 、tfoot 的顺序不会影响表格的顺序，表格总是以 head -\u0026gt; body -\u0026gt; foot 来展示。\n \u0026lt;table\u0026gt; 相关的样式  table-layout： 可取 fixed 、auto 等。fixed 则列宽度均为等宽，auto 则在设置的列宽度的基础上根据列内容自适应宽度。 border-collapse： 是用来决定表格的边框是分开的还是合并的，在分隔模式下，相邻的单元格都拥有独立的边框。在合并模式下，相邻单元格共享边框。 border-spacing： 指定相邻单元格边框之间的距离。该属性只适用于 border-collapse 值是 separate 的时候。    资料来源：饥人谷、MDN\n ","date":"2021-03-14T14:00:00Z","image":"/post/html02/html_tag_hu083f3c8badd224f94b299a0430e4c8a0_41990_720x720_fill_q75_box_smart1.jpg","permalink":"/post/html02/","title":"HTML常用标签"},{"content":"HTML是什么 超文本标记语言（HyperText Markup Language，简称：HTML），是一种用于创建网页的 标准标记语言。\nHTML的历史 HTML的首个公开描述出现于一个名为 HTML Tags 的文件中，由 蒂姆·伯纳斯-李（Tim Berners-Lee） 于 1991年底 提及。\n它描述18个元素，包括HTML初始的、相对简单的设计。点击查看 HTML Tags\n1993年中期 ，互联网工程任务组（IETF）发布首个HTML规范的提案是由 伯纳斯-李 与 丹·康纳利 撰写。\nHTML版本时间线  1995年11月24日，HTML 2.0作为IETF RFC 1866发布。 1997年1月14日，HTML 3.2作为W3C推荐标准发布。这是首个完全由W3C开发并标准化的版本，因IETF于1996年9月12日关闭了它的HTML工作组。 1997年12月18日，HTML 4.0作为W3C推荐标准发布。 1999年12月24日，HTML 4.01作为W3C推荐标准发布。 2000年5月，ISO HTML（基于HTML 4.01 严格版）作为ISO/IEC国际标准发布。 2014年10月28日，HTML 5作为W3C推荐标准发布。  HTML入门 HTML5的两个含义  指目前最新版的 HTML 语言，含旧的标签和32个新的标签； HTML5和他的朋友们（包括CSS3等）。   注：平时产品经理提及的H5页面，一般指代的是移动端页面而不是HTML5，不要被外行误导。\n HTML文件的头部（起手式） \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width,initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; HTML的语法 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;!--声明文档类型为html格式--\u0026gt; \u0026lt;tag attr=value\u0026gt;内容\u0026lt;tag/\u0026gt; \u0026lt;!--有值的属性，如：id、class...--\u0026gt; \u0026lt;tag attr\u0026gt;内容\u0026lt;/tag\u0026gt; \u0026lt;!--布尔属性（写则有不写则无），如：checked...--\u0026gt; \u0026lt;tag attr=value /\u0026gt; \u0026lt;!--单标签的旧版写法--\u0026gt; \u0026lt;tag attr=value \u0026gt; \u0026lt;!--单标签的新版写法，如：img、link...--\u0026gt; HTML的基本知识 章节标签  标题 h1～h6 章节 section 文章 article 主要内容 main 旁支内容 aside 段落 p 头部 header 底部（脚部） footer 划分 div  内容标签（常用）  有序列表 ol \u0026amp; li 无序列表 ul \u0026amp; li 用来描述的列表 dl \u0026amp; dt \u0026amp; dd 需要连续空格/换行要用 pre 包裹内容 分割线 hr 换行 br 超链接 a 强调内容（语气上的强调） em 重点内容（本身就是重点） strong 代码内容 code 内联引用 quote 块级引用 blockquote  全局属性 tag = value\n\u0026lt;p class=\u0026#34;xxx\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;!--通过 .classname 选择，可同时有多个class--\u0026gt; \u0026lt;p id=\u0026#34;xxx\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;!--通过 #id 选择，尽量不用，会与 window 的属性冲突--\u0026gt; \u0026lt;p style=\u0026#34;xxx:yyy\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;!--写法和 CSS 相同，优先级比 CSS 高；JS 的优先级比 style 更高--\u0026gt; \u0026lt;p tabindex=-1/0/1...\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;!--Tab 键切换可交互元素的顺序--\u0026gt; \u0026lt;!-- -1 则不访问，0 为最后访问，其余的由小到大顺序选择--\u0026gt; \u0026lt;img title=\u0026#34;我是描述\u0026#34;\u0026gt; \u0026lt;!--元素 hover 时弹出气泡的内容，可用来显示被隐藏的元素的完整内容--\u0026gt; 加了就有的属性\n\u0026lt;p contenteditable\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;!--为该元素添加可以被编辑的属性,用户就可以直接在网页上编辑该内容--\u0026gt; \u0026lt;img hidden\u0026gt; \u0026lt;!--使该元素隐藏起来,使用CSS的 display: block 可以重新显示该内容--\u0026gt; HTML的默认样式 Chrome开发者工具中的 user agent stylesheet 就是 HTML 的默认样式。 一般都很丑，通过创建一个 CSS 文件将部分默认样式统一。\n  资料来源：饥人谷、WikiPedia\n ","date":"2021-03-14T12:00:00Z","image":"/post/html01/html_hu421693ed6922cd23cba03c2f4829fe00_35117_720x720_fill_q75_box_smart1.jpg","permalink":"/post/html01/","title":"HTML入门笔记"}]